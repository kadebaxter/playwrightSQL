-- DROP SEQUENCE playwright_oak.actual_schedule_performer_id_seq;

CREATE SEQUENCE actual_schedule_performer_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.actual_schedule_performer_id_seq1;

CREATE SEQUENCE actual_schedule_performer_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.actual_schedule_play_id_seq;

CREATE SEQUENCE actual_schedule_play_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.actual_schedule_play_id_seq1;

CREATE SEQUENCE actual_schedule_play_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.complex_id_seq;

CREATE SEQUENCE complex_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.complex_id_seq1;

CREATE SEQUENCE complex_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.concession_item_id_seq;

CREATE SEQUENCE concession_item_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.concession_item_id_seq1;

CREATE SEQUENCE concession_item_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.customer_id_seq;

CREATE SEQUENCE customer_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.customer_id_seq1;

CREATE SEQUENCE customer_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.dual_part_certification_id_seq;

CREATE SEQUENCE dual_part_certification_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.dual_part_certification_id_seq1;

CREATE SEQUENCE dual_part_certification_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.part_certification_1_id_seq;

CREATE SEQUENCE part_certification_1_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.part_certification_1_id_seq1;

CREATE SEQUENCE part_certification_1_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.part_certification_2_id_seq;

CREATE SEQUENCE part_certification_2_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.part_certification_2_id_seq1;

CREATE SEQUENCE part_certification_2_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.part_certification_5_id_seq;

CREATE SEQUENCE part_certification_5_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.part_certification_5_id_seq1;

CREATE SEQUENCE part_certification_5_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.part_certification_6_id_seq;

CREATE SEQUENCE part_certification_6_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.part_certification_6_id_seq1;

CREATE SEQUENCE part_certification_6_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.part_certification_7_id_seq;

CREATE SEQUENCE part_certification_7_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.part_certification_7_id_seq1;

CREATE SEQUENCE part_certification_7_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.part_certification_8_id_seq;

CREATE SEQUENCE part_certification_8_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.part_certification_8_id_seq1;

CREATE SEQUENCE part_certification_8_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.part_certification_9_id_seq;

CREATE SEQUENCE part_certification_9_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.part_certification_9_id_seq1;

CREATE SEQUENCE part_certification_9_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.part_id_seq;

CREATE SEQUENCE part_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.performer_id_seq;

CREATE SEQUENCE performer_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.performer_id_seq1;

CREATE SEQUENCE performer_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.purchase_concession_id_seq;

CREATE SEQUENCE purchase_concession_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.purchase_concession_id_seq1;

CREATE SEQUENCE purchase_concession_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.purchase_concession_item_id_seq;

CREATE SEQUENCE purchase_concession_item_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.purchase_concession_item_id_seq1;

CREATE SEQUENCE purchase_concession_item_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.purchase_id_seq;

CREATE SEQUENCE purchase_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.purchase_id_seq1;

CREATE SEQUENCE purchase_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.purchase_seat_id_seq;

CREATE SEQUENCE purchase_seat_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.purchase_seat_id_seq1;

CREATE SEQUENCE purchase_seat_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.schedule_performer_template_id_seq;

CREATE SEQUENCE schedule_performer_template_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.schedule_performer_template_id_seq1;

CREATE SEQUENCE schedule_performer_template_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.schedule_play_template_week_id_seq;

CREATE SEQUENCE schedule_play_template_week_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.schedule_play_template_week_id_seq1;

CREATE SEQUENCE schedule_play_template_week_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.seat_id_seq;

CREATE SEQUENCE seat_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.seat_id_seq1;

CREATE SEQUENCE seat_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.theatre_id_seq;

CREATE SEQUENCE theatre_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE playwright_oak.theatre_id_seq1;

CREATE SEQUENCE theatre_id_seq1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;-- playwright_oak.complex definition

-- Drop table

-- DROP TABLE playwright_oak.complex;

CREATE TABLE complex (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	address varchar(80) NULL,
	CONSTRAINT complex_pkey PRIMARY KEY (id)
);


-- playwright_oak.concession_item definition

-- Drop table

-- DROP TABLE playwright_oak.concession_item;

CREATE TABLE concession_item (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	"name" varchar(80) NOT NULL,
	shelf_price money NULL,
	CONSTRAINT concession_item_pkey PRIMARY KEY (id)
);


-- playwright_oak.customer definition

-- Drop table

-- DROP TABLE playwright_oak.customer;

CREATE TABLE customer (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	"name" varchar(100) NULL,
	CONSTRAINT customer_pkey PRIMARY KEY (id)
);


-- playwright_oak.female definition

-- Drop table

-- DROP TABLE playwright_oak.female;

CREATE TABLE female (
	givenname varchar(50) NULL
);


-- playwright_oak.male definition

-- Drop table

-- DROP TABLE playwright_oak.male;

CREATE TABLE male (
	givenname varchar(50) NULL
);


-- playwright_oak.performer definition

-- Drop table

-- DROP TABLE playwright_oak.performer;

CREATE TABLE performer (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	"name" varchar(100) NOT NULL,
	CONSTRAINT performer_pkey PRIMARY KEY (id)
);


-- playwright_oak.surname definition

-- Drop table

-- DROP TABLE playwright_oak.surname;

CREATE TABLE surname (
	familysurname varchar(50) NULL
);


-- playwright_oak.dual_part_certification definition

-- Drop table

-- DROP TABLE playwright_oak.dual_part_certification;

CREATE TABLE dual_part_certification (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	performer_part_3_id int4 NOT NULL,
	performer_part_4_id int4 NOT NULL,
	date_certified date NOT NULL,
	date_expires date NOT NULL,
	CONSTRAINT dual_part_certification_pkey PRIMARY KEY (id),
	CONSTRAINT dual_part_certification_performer_1_id_fkey FOREIGN KEY (performer_part_3_id) REFERENCES performer(id),
	CONSTRAINT dual_part_certification_performer_2_id_fkey FOREIGN KEY (performer_part_4_id) REFERENCES performer(id)
);


-- playwright_oak.part_certification_1 definition

-- Drop table

-- DROP TABLE playwright_oak.part_certification_1;

CREATE TABLE part_certification_1 (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	performer_id int4 NOT NULL,
	date_certified date NULL,
	date_expires date NULL,
	CONSTRAINT part_certification_1_check CHECK ((date_expires > date_certified)),
	CONSTRAINT part_certification_1_pkey PRIMARY KEY (id),
	CONSTRAINT part_certification_1_performer_id_fkey FOREIGN KEY (performer_id) REFERENCES performer(id)
);


-- playwright_oak.part_certification_2 definition

-- Drop table

-- DROP TABLE playwright_oak.part_certification_2;

CREATE TABLE part_certification_2 (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	performer_id int4 NOT NULL,
	date_certified date NULL,
	date_expires date NULL,
	CONSTRAINT part_certification_2_check CHECK ((date_expires > date_certified)),
	CONSTRAINT part_certification_2_pkey PRIMARY KEY (id),
	CONSTRAINT part_certification_2_performer_id_fkey FOREIGN KEY (performer_id) REFERENCES performer(id)
);


-- playwright_oak.part_certification_5 definition

-- Drop table

-- DROP TABLE playwright_oak.part_certification_5;

CREATE TABLE part_certification_5 (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	performer_id int4 NOT NULL,
	date_certified date NULL,
	date_expires date NULL,
	CONSTRAINT part_certification_5_check CHECK ((date_expires > date_certified)),
	CONSTRAINT part_certification_5_pkey PRIMARY KEY (id),
	CONSTRAINT part_certification_5_performer_id_fkey FOREIGN KEY (performer_id) REFERENCES performer(id)
);


-- playwright_oak.part_certification_6 definition

-- Drop table

-- DROP TABLE playwright_oak.part_certification_6;

CREATE TABLE part_certification_6 (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	performer_id int4 NOT NULL,
	date_certified date NULL,
	date_expires date NULL,
	CONSTRAINT part_certification_6_check CHECK ((date_expires > date_certified)),
	CONSTRAINT part_certification_6_pkey PRIMARY KEY (id),
	CONSTRAINT part_certification_6_performer_id_fkey FOREIGN KEY (performer_id) REFERENCES performer(id)
);


-- playwright_oak.part_certification_7 definition

-- Drop table

-- DROP TABLE playwright_oak.part_certification_7;

CREATE TABLE part_certification_7 (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	performer_id int4 NOT NULL,
	date_certified date NULL,
	date_expires date NULL,
	CONSTRAINT part_certification_7_check CHECK ((date_expires > date_certified)),
	CONSTRAINT part_certification_7_pkey PRIMARY KEY (id),
	CONSTRAINT part_certification_7_performer_id_fkey FOREIGN KEY (performer_id) REFERENCES performer(id)
);


-- playwright_oak.part_certification_8 definition

-- Drop table

-- DROP TABLE playwright_oak.part_certification_8;

CREATE TABLE part_certification_8 (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	performer_id int4 NOT NULL,
	date_certified date NULL,
	date_expires date NULL,
	CONSTRAINT part_certification_8_check CHECK ((date_expires > date_certified)),
	CONSTRAINT part_certification_8_pkey PRIMARY KEY (id),
	CONSTRAINT part_certification_8_performer_id_fkey FOREIGN KEY (performer_id) REFERENCES performer(id)
);


-- playwright_oak.part_certification_9 definition

-- Drop table

-- DROP TABLE playwright_oak.part_certification_9;

CREATE TABLE part_certification_9 (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	performer_id int4 NOT NULL,
	date_certified date NULL,
	date_expires date NULL,
	CONSTRAINT part_certification_9_check CHECK ((date_expires > date_certified)),
	CONSTRAINT part_certification_9_pkey PRIMARY KEY (id),
	CONSTRAINT part_certification_9_performer_id_fkey FOREIGN KEY (performer_id) REFERENCES performer(id)
);


-- playwright_oak.purchase definition

-- Drop table

-- DROP TABLE playwright_oak.purchase;

CREATE TABLE purchase (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	customer_id int4 NOT NULL,
	day_sold timestamp NOT NULL,
	CONSTRAINT purchase_pkey PRIMARY KEY (id),
	CONSTRAINT purchase_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES customer(id)
);


-- playwright_oak.purchase_concession definition

-- Drop table

-- DROP TABLE playwright_oak.purchase_concession;

CREATE TABLE purchase_concession (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	complex_id int4 NULL,
	day_sold timestamp NOT NULL,
	CONSTRAINT purchase_concession_pkey PRIMARY KEY (id),
	CONSTRAINT purchase_concession_complex_id_fkey FOREIGN KEY (complex_id) REFERENCES complex(id)
);


-- playwright_oak.purchase_concession_item definition

-- Drop table

-- DROP TABLE playwright_oak.purchase_concession_item;

CREATE TABLE purchase_concession_item (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	concession_item_id int4 NULL,
	purchase_concession_id int4 NOT NULL,
	quantity int4 NULL,
	actual_price money NOT NULL,
	CONSTRAINT purchase_concession_item_pkey PRIMARY KEY (id),
	CONSTRAINT purchase_concession_item_concession_item_id_fkey FOREIGN KEY (concession_item_id) REFERENCES concession_item(id),
	CONSTRAINT purchase_concession_item_purchase_concession_id_fkey FOREIGN KEY (purchase_concession_id) REFERENCES purchase_concession(id)
);


-- playwright_oak.theatre definition

-- Drop table

-- DROP TABLE playwright_oak.theatre;

CREATE TABLE theatre (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	max_capacity int4 NULL,
	complex_id int4 NULL,
	CONSTRAINT theatre_pkey PRIMARY KEY (id),
	CONSTRAINT theatre_complexid_fkey FOREIGN KEY (complex_id) REFERENCES complex(id)
);


-- playwright_oak.actual_schedule_play definition

-- Drop table

-- DROP TABLE playwright_oak.actual_schedule_play;

CREATE TABLE actual_schedule_play (
	theatre_id int4 NOT NULL,
	scheduled_time timestamp NOT NULL,
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	CONSTRAINT actual_schedule_play_pkey PRIMARY KEY (id),
	CONSTRAINT actual_schedule_play_scheduled_time_key UNIQUE (scheduled_time),
	CONSTRAINT actual_schedule_play_theatre_id_fkey FOREIGN KEY (theatre_id) REFERENCES theatre(id)
);

-- DROP FUNCTION playwright_oak.multiple_parts_trigger();

CREATE OR REPLACE FUNCTION multiple_parts_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
	dup_count int;
begin
  with performer_list as (
        select performer_id as performer from part_certification_1 pc1 where new.cert_1_id = pc1.id
        union all
        select performer_id from part_certification_2 pc2 where new.cert_2_id = pc2.id
        union all
        select performer_id from part_certification_5 pc5 where new.cert_5_id = pc5.id
        union all
        select performer_id from part_certification_6 pc6 where new.cert_6_id = pc6.id
        union all
        select performer_id from part_certification_7 pc7 where new.cert_7_id = pc7.id
        union all
        select performer_id from part_certification_8 pc8 where new.cert_8_id = pc8.id
        union all
        select performer_id from part_certification_9 pc9 where new.cert_9_id = pc9.id
        union all
        select performer_part_3_id from dual_part_certification dpc where new.dual_cert_id = dpc.id
        union all
        select performer_part_4_id from dual_part_certification dpc where new.dual_cert_id = dpc.id
    )
    select count(*) into dup_count
    from (
        select performer, count(*)
        from performer_list
        group by performer
        having count(*) > 1
    );

	if dup_count > 0 then
		raise exception 'Duplicate actors in this showtime';
	end if;
	
	return new;
	
end;
$function$
;

-- DROP FUNCTION playwright_oak.active_cert_trigger();

CREATE OR REPLACE FUNCTION active_cert_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare 
	cert_1_expired date;
	cert_2_expired date;
	dual_cert_expired date;
	cert_5_expired date;
	cert_6_expired date;
	cert_7_expired date;
	cert_8_expired date;
	cert_9_expired date;
begin 
	select date_expires into cert_1_expired from part_certification_1 pc1 where new.cert_1_id = pc1.id;
    select date_expires into cert_2_expired from part_certification_2 pc2 where new.cert_2_id = pc2.id;
	select date_expires into cert_5_expired from part_certification_5 pc5 where new.cert_5_id = pc5.id;
	select date_expires into cert_6_expired from part_certification_6 pc6 where new.cert_6_id = pc6.id;
	select date_expires into cert_7_expired from part_certification_7 pc7 where new.cert_7_id = pc7.id;
	select date_expires into cert_8_expired from part_certification_8 pc8 where new.cert_8_id = pc8.id;
	select date_expires into cert_9_expired from part_certification_9 pc9 where new.cert_9_id = pc9.id;
	select date_expires into dual_cert_expired from dual_part_certification dpc where new.dual_cert_id = dpc.id;

	if cert_1_expired < now() 
		or cert_2_expired < now() 
		or cert_5_expired < now() 
		or cert_6_expired < now() 
		or cert_7_expired < now()
		or cert_8_expired < now()
		or cert_9_expired < now()
		or dual_cert_expired < now() then
			raise exception 'Not all certifications are up-to-date';
	end if;

	return new;
end;
$function$
;

-- playwright_oak.schedule_play_template_week definition

-- Drop table

-- DROP TABLE playwright_oak.schedule_play_template_week;

CREATE TABLE schedule_play_template_week (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	theatre_id int4 NOT NULL,
	day_of_week varchar(10) NOT NULL,
	time_of_day int4 NOT NULL,
	CONSTRAINT schedule_play_template_week_pkey PRIMARY KEY (id),
	CONSTRAINT schedule_play_template_week_theatre_id_day_of_week_time_of__key UNIQUE (theatre_id, day_of_week, time_of_day),
	CONSTRAINT schedule_play_template_week_theatre_id_fkey FOREIGN KEY (theatre_id) REFERENCES theatre(id)
);


-- playwright_oak.seat definition

-- Drop table

-- DROP TABLE playwright_oak.seat;

CREATE TABLE seat (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	theatre_id int4 NOT NULL,
	seat_num int4 NOT NULL,
	CONSTRAINT seat_pkey PRIMARY KEY (id),
	CONSTRAINT seat_theatre_id_fkey FOREIGN KEY (theatre_id) REFERENCES theatre(id)
);


-- playwright_oak.actual_schedule_performer definition

-- Drop table

-- DROP TABLE playwright_oak.actual_schedule_performer;

CREATE TABLE actual_schedule_performer (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	schedule_id int4 NOT NULL,
	cert_1_id int4 NULL,
	cert_2_id int4 NULL,
	dual_cert_id int4 NULL,
	cert_5_id int4 NULL,
	cert_6_id int4 NULL,
	cert_7_id int4 NULL,
	cert_8_id int4 NULL,
	cert_9_id int4 NULL,
	CONSTRAINT actual_schedule_performer_pkey PRIMARY KEY (id),
	CONSTRAINT actual_schedule_performer_cert_1_id_fkey FOREIGN KEY (cert_1_id) REFERENCES part_certification_1(id),
	CONSTRAINT actual_schedule_performer_cert_2_id_fkey FOREIGN KEY (cert_2_id) REFERENCES part_certification_2(id),
	CONSTRAINT actual_schedule_performer_cert_5_id_fkey FOREIGN KEY (cert_5_id) REFERENCES part_certification_5(id),
	CONSTRAINT actual_schedule_performer_cert_6_id_fkey FOREIGN KEY (cert_6_id) REFERENCES part_certification_6(id),
	CONSTRAINT actual_schedule_performer_cert_7_id_fkey FOREIGN KEY (cert_7_id) REFERENCES part_certification_7(id),
	CONSTRAINT actual_schedule_performer_cert_8_id_fkey FOREIGN KEY (cert_8_id) REFERENCES part_certification_8(id),
	CONSTRAINT actual_schedule_performer_cert_9_id_fkey FOREIGN KEY (cert_9_id) REFERENCES part_certification_9(id),
	CONSTRAINT actual_schedule_performer_dual_cert_id_fkey FOREIGN KEY (dual_cert_id) REFERENCES dual_part_certification(id),
	CONSTRAINT actual_schedule_performer_schedule_template_id_fkey FOREIGN KEY (schedule_id) REFERENCES actual_schedule_play(id)
);

-- Table Triggers

create trigger active_certs_active before
insert
    or
update
    on
    actual_schedule_performer for each row execute function active_cert_trigger();
create trigger multiple_parts_active before
insert
    or
update
    on
    actual_schedule_performer for each row execute function multiple_parts_trigger();


-- playwright_oak.purchase_seat definition

-- Drop table

-- DROP TABLE playwright_oak.purchase_seat;

CREATE TABLE purchase_seat (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	seat_id int4 NOT NULL,
	actual_schedule_play_id int4 NOT NULL,
	actual_sell_price money NULL,
	purchase_id int4 NULL,
	CONSTRAINT purchase_seat_pkey PRIMARY KEY (id),
	CONSTRAINT purchase_seat_actual_schedule_play_id_fkey FOREIGN KEY (actual_schedule_play_id) REFERENCES actual_schedule_play(id),
	CONSTRAINT purchase_seat_purchase_id_fkey FOREIGN KEY (purchase_id) REFERENCES purchase(id),
	CONSTRAINT purchase_seat_seat_id_fkey FOREIGN KEY (seat_id) REFERENCES seat(id)
);


-- playwright_oak.schedule_performer_template definition

-- Drop table

-- DROP TABLE playwright_oak.schedule_performer_template;

CREATE TABLE schedule_performer_template (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	schedule_template_id int4 NOT NULL,
	cert_1_id int4 NULL,
	cert_2_id int4 NULL,
	dual_cert_id int4 NULL,
	cert_5_id int4 NULL,
	cert_6_id int4 NULL,
	cert_7_id int4 NULL,
	cert_8_id int4 NULL,
	cert_9_id int4 NULL,
	CONSTRAINT schedule_performer_template_pkey PRIMARY KEY (id),
	CONSTRAINT schedule_performer_template_cert_1_id_fkey FOREIGN KEY (cert_1_id) REFERENCES part_certification_1(id),
	CONSTRAINT schedule_performer_template_cert_2_id_fkey FOREIGN KEY (cert_2_id) REFERENCES part_certification_2(id),
	CONSTRAINT schedule_performer_template_cert_5_id_fkey FOREIGN KEY (cert_5_id) REFERENCES part_certification_5(id),
	CONSTRAINT schedule_performer_template_cert_6_id_fkey FOREIGN KEY (cert_6_id) REFERENCES part_certification_6(id),
	CONSTRAINT schedule_performer_template_cert_7_id_fkey FOREIGN KEY (cert_7_id) REFERENCES part_certification_7(id),
	CONSTRAINT schedule_performer_template_cert_8_id_fkey FOREIGN KEY (cert_8_id) REFERENCES part_certification_8(id),
	CONSTRAINT schedule_performer_template_cert_9_id_fkey FOREIGN KEY (cert_9_id) REFERENCES part_certification_9(id),
	CONSTRAINT schedule_performer_template_dual_cert_id_fkey FOREIGN KEY (dual_cert_id) REFERENCES dual_part_certification(id),
	CONSTRAINT schedule_performer_template_schedule_template_id_fkey FOREIGN KEY (schedule_template_id) REFERENCES schedule_play_template_week(id)
);

-- Table Triggers

create trigger active_certs_template before
insert
    or
update
    on
    schedule_performer_template for each row execute function active_cert_trigger();
create trigger multiple_parts_template before
insert
    or
update
    on
    schedule_performer_template for each row execute function multiple_parts_trigger();


-- playwright_oak.availableseats source

CREATE OR REPLACE VIEW availableseats
AS SELECT a.seatid
   FROM ( SELECT s.id AS seatid
           FROM actual_schedule_play asp
             JOIN theatre t ON asp.theatre_id = t.id
             JOIN seat s ON s.theatre_id = t.id
          WHERE asp.id = 2) a
     LEFT JOIN ( SELECT ps2.seat_id AS seatid
           FROM purchase_seat ps2
          WHERE ps2.actual_schedule_play_id = 2) b ON a.seatid = b.seatid
  WHERE b.seatid IS NULL
  ORDER BY a.seatid;


-- DROP PROCEDURE playwright_oak.add_random_customer();

CREATE OR REPLACE PROCEDURE add_random_customer()
 LANGUAGE plpgsql
AS $procedure$

declare
	myName varchar(100);
begin
		insert into customer (name) 
		select * from (select 
			    concat(
			        (select givenname from female order by random() limit 1),
			        ' ',
			        (select familysurname from surname order by random() limit 1)
			    ) 		union all
				select
			    	concat(
			        	(select givenname from male order by random() limit 1),
			        	' ',
			        	(select familysurname from surname order by random() limit 1)
			    	) 
			) as B
	order by random()
	limit 1;	
end;
$procedure$
;

-- DROP PROCEDURE playwright_oak.add_random_performer();

CREATE OR REPLACE PROCEDURE add_random_performer()
 LANGUAGE plpgsql
AS $procedure$

declare
	myName varchar(100);
begin
		insert into performer (name) 
		select * from (select 
			    concat(
			        (select givenname from female order by random() limit 1),
			        ' ',
			        (select familysurname from surname order by random() limit 1)
			    ) 		union all
				select
			    	concat(
			        	(select givenname from male order by random() limit 1),
			        	' ',
			        	(select familysurname from surname order by random() limit 1)
			    	) 
			) as B
	order by random()
	limit 1;	
end;
$procedure$
;

-- DROP PROCEDURE playwright_oak.generate_new_seats(int4);

CREATE OR REPLACE PROCEDURE generate_new_seats(IN stage_id integer)
 LANGUAGE plpgsql
AS $procedure$
declare
    new_seat_num int;
    current_seat_count int;
    max_size int;
	quantity_seats_to_make int;
begin
	-- new_seat_num = one greater than current greatest seat_num
	-- new_seat_num will be my seat in the theatre like chair G12, but it is an int datatype for ease of data manipulation
    select coalesce(max(seat_num), 0) + 1
    into new_seat_num
    from seat
    where seat.theatre_id = stage_id; 

	--var current_seat_count= how many seats already exist in this table for this theatre
    select coalesce (count(*), 0) into current_seat_count
    from seat
    where seat.theatre_id = stage_id;  

	--var max_capacity = total seats my theatre can have
    select max_capacity into max_size
    from theatre
    where id = stage_id;  

	--initialize quantity_seats_to_make
	quantity_seats_to_make := max_size - current_seat_count;
	
	if quantity_seats_to_make <1 then
		raise exception 'Cannot create new seats. My Max_size of theatre: %, my quantity of seats already made: %, my number of seats left I can make: % '
			, max_size, current_seat_count, quantity_seats_to_make;
	end if;

    -- guarantee no more seats made than max capacity of theatre
    if current_seat_count >= max_size then
        raise exception 'Cannot create new seats. The total number of seats would exceed the theatre''s max_capacity of %.', max_size;
    end if;

    for i in 1..quantity_seats_to_make loop
        insert into seat (theatre_id, seat_num)  
        values (stage_id, new_seat_num);  

        new_seat_num := new_seat_num + 1;
    end loop;
end;
$procedure$
;

-- DROP PROCEDURE playwright_oak.generate_new_seats(int4, int4);

CREATE OR REPLACE PROCEDURE generate_new_seats(IN stage_id integer, IN num_seats integer)
 LANGUAGE plpgsql
AS $procedure$
declare
    new_seat_num int;
    current_seat_count int;
    max_size int;
begin
    select coalesce(max(seat_num), 0) + 1
    into new_seat_num
    from seat
    where seat.theatre_id = stage_id;  

    select count(*) into current_seat_count
    from seat
    where seat.theatre_id = stage_id;  

    select max_capacity into max_size
    from theatre
    where id = stage_id;  

    -- guarantee no more seats than max capacity of theatre
    if current_seat_count + num_seats > max_size then
        raise exception 'cannot create % new seats. the total number of seats would exceed the theatre''s max_capacity of %.',
                        num_seats, max_size;
    end if;

    for i in 1..num_seats loop
        insert into seat (theatre_id, seat_num)  
        values (stage_id, new_seat_num);  

        new_seat_num := new_seat_num + 1;
    end loop;
end;
$procedure$
;

-- DROP FUNCTION playwright_oak.get_seat(int4);

CREATE OR replace function get_seat(asp_id integer)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$

declare 
	my_seat_id int;

begin
		if asp_id is null then
			raise exception 'cannot have invalid instance of actual_schedule_play id: %', asp_id;
		end if;

			select A.seat_id 
			into my_seat_id 
				from (
	
				select 	s.id seat_id from
					actual_schedule_play asp 
					inner join
					theatre t on (asp.theatre_id = t.id)
					inner join 
					seat s on (s.theatre_id = t.id)
					where 
					asp.id = 2 -- the showing in question variable
					)	A 
		
			left outer join 
			(
				--sold seat query
				select 
					ps2.seat_id 
					from
					purchase_seat ps2
					where 
						ps2.actual_schedule_play_id = 2 -- the showing in question variable. 
			
				) B 
		on (A.seat_id = B.seat_id)
		where B.seat_id is null
		order by 1 
		limit 1;
		

		if my_seat_id is null then
			raise exception 'cannot find a ticket to sell for this actual_schedule_play id: %', asp_id;
		end if;
				

	return my_seat_id;
end;
$function$
;

-- DROP PROCEDURE playwright_oak.make_actual_performer_schedule();

CREATE OR REPLACE PROCEDURE make_actual_performer_schedule()
 LANGUAGE plpgsql
AS $procedure$
declare
begin
	insert into actual_schedule_performer(schedule_template_id, cert_1_id, cert_2_id, dual_cert_id, cert_5_id, cert_6_id, cert_7_id, cert_8_id, cert_9_id)
	select
		schedule_template_id, cert_1_id, cert_2_id, dual_cert_id, cert_5_id, cert_6_id, cert_7_id, cert_8_id, cert_9_id
	from schedule_performer_template;
end;
$procedure$
;

-- DROP PROCEDURE playwright_oak.make_actual_performer_schedule(timestamp);

CREATE OR REPLACE PROCEDURE make_actual_performer_schedule(IN day_to_schedule timestamp without time zone)
 LANGUAGE plpgsql
AS $procedure$
declare
	asp_id int;
	asp_scheduled_time timestamp;	
	next_dow varchar(10);
	next_hour int;
begin
	for asp_id, asp_scheduled_time in select id, scheduled_time from actual_schedule_play where scheduled_time >= day_to_schedule
	loop 
		next_dow = to_char(asp_scheduled_time, 'FMDay');
		next_hour = extract(hour from asp_scheduled_time)::int;

		insert into actual_schedule_performer(schedule_id, cert_1_id, cert_2_id, dual_cert_id, cert_5_id, cert_6_id, cert_7_id, cert_8_id, cert_9_id)
		select asp_id, spt.cert_1_id, spt.cert_2_id, spt.dual_cert_id, spt.cert_5_id, spt.cert_6_id, spt.cert_7_id, spt.cert_8_id, spt.cert_9_id
		from schedule_performer_template spt inner join schedule_play_template_week sptw on (sptw.id = spt.schedule_template_id)
		where sptw.day_of_week = next_dow and sptw.time_of_day = next_hour;
			
	end loop;
end;
$procedure$
;

-- DROP FUNCTION playwright_oak.make_actual_play_time(text, int4, timestamp);

CREATE OR REPLACE FUNCTION make_actual_play_time(p_day_of_week text, p_time_of_day integer, start_day timestamp without time zone)
 RETURNS timestamp without time zone
 LANGUAGE plpgsql
AS $function$
DECLARE
    start_d date := date(start_day);
    start_dow int;
    template_dow int;
    day_offset int;
    computed_play_time timestamp;
BEGIN
  
    start_dow := extract(dow from start_d)::int;

    CASE p_day_of_week
        WHEN 'Sunday' THEN template_dow := 0;
        WHEN 'Monday' THEN template_dow := 1;
        WHEN 'Tuesday' THEN template_dow := 2;
        WHEN 'Wednesday' THEN template_dow := 3;
        WHEN 'Thursday' THEN template_dow := 4;
        WHEN 'Friday' THEN template_dow := 5;
        WHEN 'Saturday' THEN template_dow := 6;
        ELSE
            RAISE EXCEPTION 'Invalid day of week: %', p_day_of_week;
    END CASE;

    day_offset := (template_dow - start_dow + 7) % 7;

    IF day_offset = 0 AND ((start_d + ((p_time_of_day::text || ' hours')::interval)) < start_day) THEN
        day_offset := 7;
    END IF;

    computed_play_time := (start_d + day_offset) + ((p_time_of_day::text || ' hours')::interval);

    RETURN computed_play_time;
END;
$function$
;

-- DROP FUNCTION playwright_oak.make_actual_play_time(text, int4);

CREATE OR REPLACE FUNCTION make_actual_play_time(p_day_of_week text, p_time_of_day integer)
 RETURNS timestamp without time zone
 LANGUAGE plpgsql
AS $function$
DECLARE
    current_d date := current_date;
    current_dow int;
    template_dow int;
    day_offset int;
    computed_play_time timestamp;
BEGIN
    -- Get today's day-of-week (0=Sun, 1=Mon, etc.)
    current_dow := extract(dow from current_d)::int;

    -- Map text day to a number
    CASE p_day_of_week
        WHEN 'Sunday' THEN template_dow := 0;
        WHEN 'Monday' THEN template_dow := 1;
        WHEN 'Tuesday' THEN template_dow := 2;
        WHEN 'Wednesday' THEN template_dow := 3;
        WHEN 'Thursday' THEN template_dow := 4;
        WHEN 'Friday' THEN template_dow := 5;
        WHEN 'Saturday' THEN template_dow := 6;
        ELSE
            RAISE EXCEPTION 'Invalid day of week: %', p_day_of_week;
    END CASE;

    -- Calculate day offset to the next occurrence of the scheduled day
    day_offset := (template_dow - current_dow + 7) % 7;

    -- If scheduled day is today but the scheduled time has passed, schedule for next week.
    IF day_offset = 0 AND ((current_d + ((p_time_of_day::text || ' hours')::interval)) < now()) THEN
        day_offset := 7;
    END IF;

    -- Compute the full timestamp
    computed_play_time := (current_d + day_offset) + ((p_time_of_day::text || ' hours')::interval);

    RETURN computed_play_time;
END;
$function$
;

-- DROP PROCEDURE playwright_oak.make_actual_schedule();

CREATE OR REPLACE PROCEDURE make_actual_schedule()
 LANGUAGE plpgsql
AS $procedure$
declare
	hour_of_play int;
	day_of_play varchar(8);
	current_dow int;
	template_dow int;
	play_time_actual timestamp;
	day_offset int;
	play_time_template time;
begin
	select day_of_week into day_of_play from schedule_play_template_week;
	select time_of_day into hour_of_play from schedule_play_template_week;
	select extract(dow from now())::int into current_dow;

	 case day_of_play
        when 'Sunday' then template_dow = 0;
        when 'Monday' then template_dow = 1;
        when 'Tuesday' then template_dow = 2;
        when 'Wednesday' then template_dow = 3;
        when 'Thursday' then template_dow = 4;
        when 'Friday' then template_dow = 5;
        when 'Saturday' then template_dow = 6;
        else
            raise exception 'Invalid day of week: %', day_of_play;
    end case;

	day_offset = (template_dow - current_dow + 7) % 7;
	play_time_actual = (current_date + day_offset) + ((hour_of_play::text || 'hours')::interval);

	if (day_offset = 0) and (play_time_template < now()::time) then
		play_time_actual = (current_date + 7) + ((hour_of_play::text || 'hours')::interval);
	end if;

	raise notice 'play time is: %', play_time_actual;
end;
$procedure$
;

-- DROP PROCEDURE playwright_oak.make_actual_week_schedule(timestamp);

CREATE OR REPLACE PROCEDURE make_actual_week_schedule(IN start_day timestamp without time zone)
 LANGUAGE plpgsql
AS $procedure$
BEGIN
    INSERT INTO actual_schedule_play(theatre_id, scheduled_time)
    SELECT 
        theatre_id, 
        make_actual_play_time(day_of_week, time_of_day, start_day) AS scheduled_time
    FROM schedule_play_template_week;
END;
$procedure$
;

-- DROP PROCEDURE playwright_oak.make_actual_week_schedule();

CREATE OR REPLACE PROCEDURE make_actual_week_schedule()
 LANGUAGE plpgsql
AS $procedure$
BEGIN
    INSERT INTO actual_schedule_play(theatre_id, scheduled_time)
    SELECT 
        theatre_id, 
        make_actual_play_time(day_of_week, time_of_day) AS scheduled_time
    FROM schedule_play_template_week;
END;
$procedure$
;

-- DROP PROCEDURE playwright_oak.make_performer_template_data();

CREATE OR REPLACE PROCEDURE make_performer_template_data()
 LANGUAGE plpgsql
AS $procedure$
declare
	cert_1_ids int[];
	cert_2_ids int[];
	dual_cert_ids int[];
	cert_5_ids int[];
	cert_6_ids int[];
	cert_7_ids int[];
	cert_8_ids int[];
	cert_9_ids int[];
begin
	select array_agg(id order by id) into cert_1_ids from part_certification_1;
	select array_agg(id order by id) into cert_2_ids from part_certification_2;
	select array_agg(id order by id) into dual_cert_ids from dual_part_certification;
	select array_agg(id order by id) into cert_5_ids from part_certification_5;
	select array_agg(id order by id) into cert_6_ids from part_certification_6;
	select array_agg(id order by id) into cert_7_ids from part_certification_7;
	select array_agg(id order by id) into cert_8_ids from part_certification_8;
	select array_agg(id order by id) into cert_9_ids from part_certification_9;

	insert into schedule_performer_template(schedule_template_id, cert_1_id, cert_2_id, dual_cert_id, cert_5_id, cert_6_id, cert_7_id, cert_8_id, cert_9_id)
	select 
		series.n as schedule_template_id
		, cert_1_ids[(series.n % array_length(cert_1_ids, 1)) + 1] as cert_1_id
		, cert_2_ids[(series.n % array_length(cert_2_ids, 1)) + 1] as cert_2_id
		, dual_cert_ids[(series.n % array_length(cert_1_ids, 1)) + 1] as cert_1_id
		, cert_5_ids[(series.n % array_length(cert_5_ids, 1)) + 1] as cert_5_id
		, cert_6_ids[(series.n % array_length(cert_6_ids, 1)) + 1] as cert_6_id
		, cert_7_ids[(series.n % array_length(cert_7_ids, 1)) + 1] as cert_7_id
		, cert_8_ids[(series.n % array_length(cert_8_ids, 1)) + 1] as cert_8_id
		, cert_9_ids[(series.n % array_length(cert_9_ids, 1)) + 1] as cert_9_id
	from generate_series(1, 91) as series(n);
end;
$procedure$
;

-- DROP PROCEDURE playwright_oak.make_play_template_data();

CREATE OR REPLACE PROCEDURE make_play_template_data()
 LANGUAGE plpgsql
AS $procedure$
declare
	theatre_ids int[];
begin
	select array_agg(id order by id) into theatre_ids from theatre;

	insert into schedule_play_template_week(theatre_id, day_of_week, time_of_day)
	select 
		theatre_ids[(series.n % array_length(theatre_ids, 1)) + 1] as theatre_id
		, case (series.n / 13)
			when 0 then 'Monday'
			when 1 then 'Tuesday'
			when 2 then 'Wednesday'
			when 3 then 'Thursday'
			when 4 then 'Friday'
			when 5 then 'Saturday'
			when 6 then 'Sunday'
		end as day_of_week
		, (series.n % 13) + 7 as time_of_day
	from generate_series(0, 90) as series(n);
	
end;
$procedure$
;

-- DROP FUNCTION playwright_oak.multiple_parts_constraint();

CREATE OR REPLACE FUNCTION multiple_parts_constraint()
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
declare
	dup_count int;
begin
	select count(*) into dup_count 
	from (
		select performer, count(*)
		from (
			select performer_id as performer from part_certification pc inner join actual_scheduler_performer asp on (asp.cert_1_id = pc.id) union all
			select performer_id from part_certification pc inner join actual_scheduler_performer asp on (asp.cert_2_id = pc.id) union all
			select performer_id from part_certification pc inner join actual_scheduler_performer asp on (asp.cert_5_id = pc.id) union all
			select performer_id from part_certification pc inner join actual_scheduler_performer asp on (asp.cert_6_id = pc.id) union all
			select performer_id from part_certification pc inner join actual_scheduler_performer asp on (asp.cert_7_id = pc.id) union all
			select performer_id from part_certification pc inner join actual_scheduler_performer asp on (asp.cert_8_id = pc.id) union all
			select performer_id from part_certification pc inner join actual_scheduler_performer asp on (asp.cert_9_id = pc.id) union all
			select performer_1_id from dual_part_certification dpc inner join actual_scheduler_performer asp on (asp.cert_3_4_id = dpc.id) union all
			select performer_2_id from dual_part_certification dpc inner join actual_scheduler_performer asp on (asp.cert_3_4_id = dpc.id)
			)
		group by performer
		having count(*) > 1 );
	
	if dup_count > 0 then 
		return false;
	else 
		return true;
	end if;
end;
$function$
;


-- DROP PROCEDURE playwright_oak.populate_theatre_complex();

CREATE OR REPLACE PROCEDURE populate_theatre_complex()
 LANGUAGE plpgsql
AS $procedure$
begin
	insert into complex(address) values (concat(floor(random() * 101), ' Street'));
	insert into complex(address) values (concat(floor(random() * 101), ' Street'));
	insert into theatre(max_capacity, complex_id) 
		select floor(random() * 501)
		, (select id from complex order by random() limit 1) as complex_id 
		from generate_series(1, 3, 1);
end;
$procedure$
;

-- DROP PROCEDURE playwright_oak.sell_tickets(int4, int4, int4, timestamp, money);

CREATE OR REPLACE PROCEDURE sell_tickets(IN qty integer, IN asp_id integer, IN cust_id integer, IN time_sold timestamp without time zone, IN price_per_seat money)
 LANGUAGE plpgsql
AS $procedure$

declare 
			--MAKE FUNCTION TO THROW ERROR IF TRY TO BUY TICKET 
			-- FOR SHOW THAT ALREADY PASSED 
	myTime timestamp; -- time of play showing
	iteration int := 0;
	purch_id int;
	my_seat_id int;
begin

	 
	--default time_sold is now()
	if time_sold is null then
		time_sold = now();
	end if;

	-- default qty = 1
	if qty is null then
		qty := 1;
	end if;

	--default cust_id is random()
	if cust_id is null then
		select id into cust_id 
					from playwright_oak.customer 
					order by random() 
					limit 1;
	end if;

	-- default asp_id is random() where it's start date > the timestamp of when said ticket was sold. 
	if asp_id is null then
		select id into asp_id 
					from actual_schedule_play 
					where scheduled_time > time_sold 
					order by random() 
					limit 1;
	end if;
	
	if asp_id is null then
		raise exception 'My Actual_Play_Id: % was inputted null and Could not find a future showing to sell tickets to.', asp_id;
	end if;

	--initialize my variable saying when the play will start. 
	select scheduled_time into myTime
				from actual_schedule_play 
				where id = asp_id;

	-- throw an error if you're buying a ticket for a play that already passed.
	if  myTime < time_sold then
		raise exception 'cannot purchase a ticket for a show that has already passed. You entered show id: %'
						, asp_id; 
	end if;


	--insert into purchase table

	insert into purchase (customer_id, day_sold)
		values (cust_id, time_sold);

	-- set purch_id to be an fk to the purchase table
	-- this way all subsequent tickets sold in this procedure call to point to the same purchase.
	select id into purch_id from purchase where day_sold = time_sold limit 1;


	--loop for purchase_ticket table
	--insert into purchase_seat
	for i in 1..qty loop 
		my_seat_id := get_seat(asp_id);

		insert into purchase_seat 
					(purchase_id
					, seat_id
					, actual_sell_price
					, actual_schedule_play_id)

			values (purch_id
					, my_seat_id	
					,price_per_seat
					,asp_id);
			
	end loop;

end;
$procedure$
;

-- DROP PROCEDURE playwright_oak.set_performer_certifications();

CREATE OR REPLACE PROCEDURE set_performer_certifications()
 LANGUAGE plpgsql
AS $procedure$
declare
	i int;
begin
	for i in select id from performer order by id loop
		if i % 9 = 0 then
			insert into part_certification_1(performer_id, date_certified, date_expires)
			values (i, now(), now() + interval '3 months');
		elsif i % 9 = 1 then
			insert into part_certification_2(performer_id, date_certified, date_expires)
			values (i, now(), now() + interval '3 months');
		elsif i % 9 = 2 then
			insert into dual_part_certification(performer_part_3_id, performer_part_4_id, date_certified, date_expires)
			values (i, i + 1, now(), now() + interval '3 months');
		elsif i % 9 = 4 then
			insert into part_certification_5(performer_id, date_certified, date_expires)
			values (i, now(), now() + interval '3 months');
		elsif i % 9 = 5 then
			insert into part_certification_6(performer_id, date_certified, date_expires)
			values (i, now(), now() + interval '3 months');
		elsif i % 9 = 6 then
			insert into part_certification_7(performer_id, date_certified, date_expires)
			values (i, now(), now() + interval '3 months');
		elsif i % 9 = 7 then
			insert into part_certification_8(performer_id, date_certified, date_expires)
			values (i, now(), now() + interval '3 months');
		elsif i % 9 = 8 then
			insert into part_certification_9(performer_id, date_certified, date_expires)
			values (i, now(), now() + interval '3 months');
		end if;
	end loop;
end;
$procedure$
;